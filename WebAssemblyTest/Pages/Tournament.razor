@using System.Collections.Generic
@using System.Linq
@using WebAssemblyTest.Models.TournamentTree
@page "/tournament"

<div style="padding:18px; display:flex; justify-content:center;">
    <div style="width:1100px;">
        <h2 style="text-align:center; margin:0 0 12px 0;">12-Player Tournament Bracket (interaktiv)</h2>

        <svg width="1100" height="@SvgHeight" viewBox="0 0 1100 @SvgHeight" xmlns="http://www.w3.org/2000/svg" style="background:#fff;">
            <!-- Runde labels -->
            <text x="80" y="30" font-size="16" font-weight="700">Runde 1</text>
            <text x="340" y="30" font-size="16" font-weight="700">Runde 2</text>
            <text x="640" y="30" font-size="16" font-weight="700">Semifinale</text>
            <text x="940" y="30" font-size="16" font-weight="700">Finale</text>

            @foreach (var info in RenderInfos)
            {
                var xPos = info.BoxLeftX + BoxW / 2;
                var yPos = info.RightY + BoxH * 0.66;

                <!-- Left participant rect -->
                if (info.HasLeftParticipant)
                {
                    <rect x="@info.BoxLeftX" y="@info.LeftY" width="@BoxW" height="@BoxH" rx="6"
                          fill="@(IsHovered(info.Match) ? HoverPlayerFill : PlayerFill)"
                          stroke="@(IsSelected(info.Match) ? SelectedStroke : PlayerStroke)"
                          style="cursor:pointer"
                          @onclick="() => OnPlayerClick(info.Match, true)" />
                        
                    <g>
                        <text x="@(info.BoxLeftX + BoxW/2)" y="@(@info.LeftY + BoxH*0.66)" text-anchor="middle" font-size="13" font-weight="600">@info.Match.LeftPartisipant</text>
                    </g>
                       
                }
                <!-- Right participant rect -->
                if (info.HasRightParticipant)
                {
                    <rect x="@info.BoxLeftX" y="@info.RightY" width="@BoxW" height="@BoxH" rx="6"
                          fill="@(IsHovered(info.Match) ? HoverPlayerFill : PlayerFill)"
                          stroke="@(IsSelected(info.Match) ? SelectedStroke : PlayerStroke)"
                          style="cursor:pointer"
                          @onclick="() => OnPlayerClick(info.Match, false)" />
                          
                    <g>
                        <text x="@(info.BoxLeftX + BoxW/2)" y="@(@info.RightY + BoxH*0.66)" text-anchor="middle" font-size="13" font-weight="600">@info.Match.RightPartisipant</text>
                    </g>
                          
                }

                <!-- VS box (center) clickable -->
                <rect x="@(info.VsX)" y="@(info.CenterY - VsH/2)" width="@VsW" height="@VsH" rx="6"
                      fill="@(IsSelected(info.Match) ? SelectedVsFill : (IsHovered(info.Match) ? HoverVsFill : VsFill))"
                      stroke="@(IsSelected(info.Match) ? SelectedVsStroke : VsStroke)"
                      style="cursor:pointer"
                      @onmouseenter="() => SetHover(info.Match, true)"
                      @onmouseleave="() => SetHover(info.Match, false)"
                      @onclick="() => ToggleSelected(info.Match)" />
                      
                <g>
                    <text x="@(info.VsX + VsW/2)" y="@(info.CenterY + VsH*0.22)" text-anchor="middle" font-size="13" font-weight="700" fill="#fff">VS</text>
                </g>
                      

                <!-- Connectors from children -->
                @if (info.LeftChildInfo != null)
                {
                    <polyline points="@($"{info.LeftChildInfo.VsX + VsW},{info.LeftChildInfo.CenterY} {info.LeftChildInfo.VsX + VsW + HGap/2},{info.LeftChildInfo.CenterY} {info.VsX - HGap/2},{info.CenterY} {info.VsX},{info.CenterY}")"
                              stroke="#222" stroke-width="2" fill="none" />
                }
                @if (info.RightChildInfo != null)
                {
                    <polyline points="@($"{info.RightChildInfo.VsX + VsW},{info.RightChildInfo.CenterY} {info.RightChildInfo.VsX + VsW + HGap/2},{info.RightChildInfo.CenterY} {info.VsX - HGap/2},{info.CenterY} {info.VsX},{info.CenterY}")"
                              stroke="#222" stroke-width="2" fill="none" />
                }
            }
        </svg>

        <div style="display:flex; gap:18px; margin-top:10px; justify-content:center;">
            <div style="font-size:13px; color:#555;">
                Klik på en blå <strong>VS</strong>-boks for at markere matchen som <em>valgt</em>. Hover for at fremhæve.
            </div>
            <button style="padding:8px 12px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer;"
                    @onclick="ClearSelection">Ryd markering</button>
        </div>
    </div>
</div>

@code {
    // PARAMETERS
    [Parameter]
    public IList<string> Participants { get; set; } = new List<string>
    {
        "1","2","3","4","5","6","7","8","9","10","11","12"
    };

    // LAYOUT CONSTANTS
    private const double BoxW = 120;
    private const double BoxH = 30;
    private const double VsW = 90;
    private const double VsH = 28;
    private const double ColW = 300;
    private const double HGap = 20;
    private const double VGap = 14;
    private const double LeftMargin = 50;
    private const double TopMargin = 70;

    // Colors
    private string PlayerFill = "#f5f5f5";
    private string PlayerStroke = "#333";
    private string HoverPlayerFill = "#eef6ff";

    private string VsFill = "#1976d2";
    private string VsStroke = "#0f57a1";
    private string HoverVsFill = "#155fa8";

    private string SelectedVsFill = "#2e7d32"; // green when selected
    private string SelectedVsStroke = "#1b5e20";
    private string SelectedStroke = "#1b5e20";

    // state
    private double SvgHeight = 820;
    private Match? RootMatch;
    private List<RenderInfo> RenderInfos = new List<RenderInfo>();
    private Dictionary<Match, bool> HoverMap = new Dictionary<Match, bool>();
    private HashSet<Match> SelectedMatches = new HashSet<Match>();

    protected override void OnInitialized()
    {
        RootMatch = CreateNewMatch(Participants.ToList(), null);

        if (RootMatch != null)
        {
            RenderInfos.Clear();
            SpanCache.Clear();
            ComputeSpan(RootMatch);
            double rootX = LeftMargin + 3 * ColW;
            double currentY = TopMargin;
            AssignPositions(RootMatch, rootX, ref currentY);
            SvgHeight = Math.Max(SvgHeight, currentY + 80);
        }
    }

    // --- same CreateNewMatch as your algorithm ---
    private Match CreateNewMatch(IList<string> partisipants, Match? nextMatch)
    {
        Match newMatch = new Match();
        newMatch.NextMatch = nextMatch;

        if (partisipants.Count == 2)
        {
            newMatch.LeftPartisipant = partisipants[0];
            newMatch.RightPartisipant = partisipants[1];
        }
        else if (partisipants.Count == 3)
        {
            int half = (int)Math.Ceiling(partisipants.Count / 2.0);
            newMatch.LeftMatch = CreateNewMatch(partisipants.Take(half).ToList(), newMatch);
            newMatch.RightPartisipant = partisipants[2];
        }
        else
        {
            int half = (int)Math.Ceiling(partisipants.Count / 2.0);
            newMatch.LeftMatch = CreateNewMatch(partisipants.Take(half).ToList(), newMatch);
            newMatch.RightMatch = CreateNewMatch(partisipants.Skip(half).ToList(), newMatch);
        }

        return newMatch;
    }

    // --- layout helpers (same approach as previous component) ---
    private Dictionary<Match, double> SpanCache = new Dictionary<Match, double>();

    private double ComputeSpan(Match m)
    {
        if (m == null) return BoxH + VGap;
        if (SpanCache.ContainsKey(m)) return SpanCache[m];

        double leftSpan = 0;
        double rightSpan = 0;

        if (m.LeftMatch != null) leftSpan = ComputeSpan(m.LeftMatch);
        else if (!string.IsNullOrEmpty(m.LeftPartisipant)) leftSpan = BoxH + VGap;

        if (m.RightMatch != null) rightSpan = ComputeSpan(m.RightMatch);
        else if (!string.IsNullOrEmpty(m.RightPartisipant)) rightSpan = BoxH + VGap;

        double total = 0;
        if (leftSpan > 0 && rightSpan > 0) total = leftSpan + rightSpan;
        else total = Math.Max(leftSpan, rightSpan);

        double min = BoxH * 2 + VGap;
        total = Math.Max(total, min);

        SpanCache[m] = total;
        return total;
    }

    private class RenderInfo
    {
        public Match Match { get; set; } = null!;
        public double BoxLeftX { get; set; }
        public double VsX { get; set; }
        public double CenterY { get; set; }
        public double LeftY { get; set; }
        public double RightY { get; set; }
        public RenderInfo? LeftChildInfo { get; set; }
        public RenderInfo? RightChildInfo { get; set; }
        public bool HasLeftParticipant { get; set; }
        public bool HasRightParticipant { get; set; }
    }

    private RenderInfo AssignPositions(Match m, double x, ref double currentY)
    {
        double span = SpanCache.ContainsKey(m) ? SpanCache[m] : ComputeSpan(m);

        RenderInfo? leftInfo = null;
        RenderInfo? rightInfo = null;

        double childX = x - ColW;

        if (m.LeftMatch != null) leftInfo = AssignPositions(m.LeftMatch, childX, ref currentY);
        else if (!string.IsNullOrEmpty(m.LeftPartisipant))
        {
            leftInfo = new RenderInfo { Match = m, BoxLeftX = childX };
            leftInfo.LeftY = currentY;
            currentY += BoxH + VGap;
        }

        if (m.RightMatch != null) rightInfo = AssignPositions(m.RightMatch, childX, ref currentY);
        else if (!string.IsNullOrEmpty(m.RightPartisipant))
        {
            rightInfo = new RenderInfo { Match = m, BoxLeftX = childX };
            rightInfo.LeftY = currentY;
            currentY += BoxH + VGap;
        }

        var info = new RenderInfo { Match = m, LeftChildInfo = leftInfo, RightChildInfo = rightInfo };

        double leftCenter = 0; double rightCenter = 0;
        bool hasLeft = false, hasRight = false;

        if (leftInfo != null)
        {
            leftInfo.VsX = leftInfo.VsX == 0 ? leftInfo.BoxLeftX + BoxW : leftInfo.VsX;
            leftInfo.CenterY = leftInfo.CenterY == 0 ? (leftInfo.LeftY + BoxH/2) : leftInfo.CenterY;
            leftCenter = leftInfo.CenterY; hasLeft = true;
        }
        if (rightInfo != null)
        {
            rightInfo.VsX = rightInfo.VsX == 0 ? rightInfo.BoxLeftX + BoxW : rightInfo.VsX;
            rightInfo.CenterY = rightInfo.CenterY == 0 ? (rightInfo.LeftY + BoxH/2) : rightInfo.CenterY;
            rightCenter = rightInfo.CenterY; hasRight = true;
        }

        double centerY;
        if (hasLeft && hasRight) centerY = (leftCenter + rightCenter) / 2.0;
        else if (hasLeft) centerY = leftCenter;
        else if (hasRight) centerY = rightCenter;
        else
        {
            centerY = currentY;
            currentY += BoxH + VGap;
        }

        info.CenterY = centerY;
        if (!string.IsNullOrEmpty(m.LeftPartisipant) && !string.IsNullOrEmpty(m.RightPartisipant))
        {
            double top = centerY - (BoxH + VGap/2);
            info.LeftY = top;
            info.RightY = top + BoxH + VGap/2;
            info.HasLeftParticipant = info.HasRightParticipant = true;
        }
        else
        {
            if (!string.IsNullOrEmpty(m.LeftPartisipant))
            {
                info.LeftY = centerY - BoxH/2;
                info.HasLeftParticipant = true;
            }
            if (!string.IsNullOrEmpty(m.RightPartisipant))
            {
                info.RightY = centerY - BoxH/2;
                info.HasRightParticipant = true;
            }
        }

        info.VsX = x - VsW/2;
        info.BoxLeftX = info.VsX - (BoxW + 14);
        if (leftInfo != null && leftInfo.VsX == 0) leftInfo.VsX = leftInfo.BoxLeftX + BoxW;
        if (rightInfo != null && rightInfo.VsX == 0) rightInfo.VsX = rightInfo.BoxLeftX + BoxW;

        RenderInfos.Add(info);
        return info;
    }

    // Hover / selection helpers
    private void SetHover(Match m, bool isHover)
    {
        if (m == null) return;
        HoverMap[m] = isHover;
        StateHasChanged();
    }

    private bool IsHovered(Match m)
    {
        return m != null && HoverMap.ContainsKey(m) && HoverMap[m];
    }

    private void ToggleSelected(Match m)
    {
        if (m == null) return;
        if (SelectedMatches.Contains(m)) SelectedMatches.Remove(m);
        else SelectedMatches.Add(m);
    }

    private bool IsSelected(Match m) => m != null && SelectedMatches.Contains(m);

    private void ClearSelection() { SelectedMatches.Clear(); HoverMap.Clear(); StateHasChanged(); }

    // Clicking a player rect currently behaves like selecting the match (could be extended)
    private void OnPlayerClick(Match m, bool isLeft)
    {
        // For now, click on player rect toggles selection of the match
        ToggleSelected(m);
    }
}